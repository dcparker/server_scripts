#!/usr/bin/env ruby

# Cilantro is a simple app structure for use with Sinatra, and this is the
# start/stop/restart script. All it does is step into the given directory,
# and require sinatra and then config/init.rb. It'll record its pid to a
# file and run Sinatra on the port you specify -- allowing you to stop and
# restart that same program as you wish. All you have to give it a
# directory to run it from, but you'll probably want to give it a port too.

require 'optparse'

def safefork
  tryagain = true

  while tryagain
    tryagain = false
    begin
      if pid = fork
        return pid
      end
    rescue Errno::EWOULDBLOCK
      sleep 5
      tryagain = true
    end
  end
end

def redirect_io(logfile_name)
  begin; STDIN.reopen "/dev/null"; rescue ::Exception; end       
   
  if logfile_name
    begin
      STDOUT.reopen logfile_name, "a"
      STDOUT.sync = true
    rescue ::Exception
      begin; STDOUT.reopen "/dev/null"; rescue ::Exception; end
    end
  else
    begin; STDOUT.reopen "/dev/null"; rescue ::Exception; end
  end
  
  begin; STDERR.reopen STDOUT; rescue ::Exception; end
  STDERR.sync = true
end

options = {}

optparse = OptionParser.new do |opts|
  opts.banner = "Usage: cilantro [action=start] [directory=.] [options]"

  options[:verbose] = false
  opts.on( '-v', '--verbose', "Show me what you're doing" ) do
    options[:verbose] = true
  end

  options[:port] = 5000
  opts.on( '-p', '--port PORT', "Listen on port PORT (default 5000)" ) do |port|
    options[:port] = port
    options[:specified_port] = true
  end

  options[:config] = nil
  opts.on( '-c', '--config CONFIG', "Use config file CONFIG" ) do |config|
    raise if !File.exists?(config)
    options[:config] = config
  end

  opts.on( '-h', '--help', 'Display this screen' ) do
    puts opts
    exit
  end
end

optparse.parse!

action = ARGV[0]
directory = ARGV[1]
if directory.nil?
  if action =~ /^(run|start|stop|status|restart)$/
    directory = Dir.pwd
  elsif action.nil?
    directory = Dir.pwd
    action = 'run'
  else
    directory = action
    action = 'run'
  end
end
if directory == '.'
  directory = Dir.pwd
end

if (options[:config] || (!options[:specified_port] && File.exists?("#{directory}/config/cilantro.run"))) && action =~ /start/
  config = File.read(options[:config] || "#{directory}/config/cilantro.run")
  # Currently all we read is a list of ports to run it on.
  ports = config.split(/\n/).collect {|line| line.gsub(/\D/,'').to_i}.select {|line| line > 0}
  options[:port] = ports.pop
  # Then we need to start a few more starter processes if there are more ports to run on
  ports.each do |port|
    system "#{$0} #{action} \"#{directory}\" --port #{port}#{' --verbose' if options[:verbose]}"
  end
end

# Start our stuff
Dir.chdir(directory)

case action
when 'run'
  if File.exists?('config/init.rb')
    require 'rubygems'
    require 'sinatra'
    Sinatra::Application.set :port, options[:port]
    require 'config/init'
  else
    puts "ERROR: #{directory} doesn't seem to be a Cilantro directory (missing config/init.rb)"
    exit
  end
when 'start'
  # Check whether environment is sane...
  #   - config/init
  if File.exists?('config/init.rb')
    puts "[START] Cilantro app in #{directory} on port #{options[:port]}..."

    # Fork to a daemon now...
    srand # Split rand streams between spawning and daemonized process
    safefork and exit # Fork and exit from the parent
    # Detach from the controlling terminal
    unless sess_id = Process.setsid
      raise Daemons.RuntimeException.new('cannot detach from controlling terminal')
    end
    # Prevent the possibility of acquiring a controlling terminal
    #if oldmode.zero?
      trap 'SIGHUP', 'IGNORE'
      safefork and exit
    #end
    $0 = "cilantro [#{options[:port]}]"
    File.umask 0000 # Insure sensible umask
    # Make sure all file descriptors are closed
    ObjectSpace.each_object(IO) do |io|
      unless [STDIN, STDOUT, STDERR].include?(io)
        begin
          unless io.closed?
            io.close
          end
        rescue ::Exception
        end
      end
    end
    $process_id = Process.pid

    redirect_io(File.directory?('log') ? "log/cilantro.#{options[:port]}.log" : "config/cilantro.#{options[:port]}.log")

    File.open("config/cilantro.#{$process_id}.pid", 'w') do |pidfile|
      pidfile << options[:port]
    end

    at_exit {
      File.delete("config/cilantro.#{$process_id}.pid")
    }

    require 'rubygems'
    require 'sinatra'
    Sinatra::Application.set :run, Proc.new { true }
    Sinatra::Application.set :port, options[:port]
    require 'config/init'
  else
    puts "ERROR: #{directory} doesn't seem to be a Cilantro directory (missing config/init.rb)"
    exit
  end
when 'status'
  count = 0
  pidfiles = Dir.glob("config/cilantro.*.pid")
  pidfiles.each do |pidfile|
    pid = pidfile.match(/(\d+)/)[0]
    port = File.read(pidfile).chomp
    if options[:port] == port || !options[:specified_port]
      puts "[STATUS] Cilantro app running on port #{port}..."
      count += 1
    end
  end
  puts "#{count} Cilantro running for #{directory}."
when 'stop'
  count = 0
  pidfiles = Dir.glob("config/cilantro.*.pid")
  pidfiles.each do |pidfile|
    pid = pidfile.match(/(\d+)/)[0]
    port = File.read(pidfile).chomp
    if options[:port] == port || !options[:specified_port]
      puts "[STOP] Cilantro app in #{directory} on port #{port}..."
      Process.kill("INT", pid.to_i)
      count += 1
    end
  end
  puts "Stopped #{count} Cilantro services."
when 'restart'
  puts "sorry, not yet implemented...\n\nWhat I want here is to restart all cilantro services that match the commandline specifications, but each with the full options they started with."
end
