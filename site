#!/usr/bin/env ruby

require 'ftools'
require 'yaml'

$user = ENV['SUDO_USER'] || ENV['USER']

unless File.directory?("#{ENV['HOME']}/SiteConfigs")
  File.makedirs("#{ENV['HOME']}/SiteConfigs")
  system("chown #{$user}:#{$user} #{ENV['HOME']}/SiteConfigs")
end
Dir.chdir("#{ENV['HOME']}/SiteConfigs")

###############################
# Self-contained mini-library #
###############################
def port_range
  $port_range ||= begin
    if !File.exists?("#{ENV['HOME']}/SiteConfigs/.port_range")
      puts "Please echo '####' > ~/SiteConfigs/.port_range, #### being the beginning port number, in the thousands, that you will be using. Port numbers used will be assigned starting at ##10, adding 10 for each subsequent site generated by this command. Yes, I manage it myself."
      exit
    end
    File.read("#{ENV['HOME']}/SiteConfigs/.port_range").gsub(/\D/,'').to_i
  end
end

String::ALPHANUMERIC_CHARACTERS = ('0'..'9').to_a + ('a'..'z').to_a + ('A'..'Z').to_a
def String.random(size)
  length = String::ALPHANUMERIC_CHARACTERS.length
  (0...size).collect { String::ALPHANUMERIC_CHARACTERS[Kernel.rand(length)] }.join
end
# Starts with defaults (hash), updates with what's currently in the file, then rewrites the file.
def YAML.update_file(file)
  raise ArgumentError, "Must pass block!" unless block_given?
  from_yaml = File.exists?(file) ? (YAML.load_file(file) || {}) : {}
  new_yaml = yield(from_yaml)
  File.open(file, 'w') do |yaml_file|
    yaml_file << new_yaml.to_yaml
  end
end

def mysql(command)
  response = `echo "#{command};" | mysql --defaults-extra-file=/root/.my.cnf 2>&1`
  if $?.exitstatus == 0
    return true, ''
  else
    if response =~ /ERROR (\d+)/
      return false, [response.match(/ERROR (\d+)/)[1].to_i, response]
    else
      return false, [response, response]
    end
  end
end

def interpolate(fulltext, replace={})
  replace.each do |key,value|
    fulltext.gsub!(/\[#{key.to_s}\]/, value.to_s)
  end
  fulltext
end
#################################

require 'optparse'
options = {}
optparse = OptionParser.new do |opts|
  opts.banner = "Usage: site (new|activate|deactivate|list|restart) [OPTIONS] domain.com"

  # options[:verbose] = false
  # opts.on( '-v', '--verbose', "Show me what you're doing" ) do
  #   options[:verbose] = true
  # end

  options[:thin] = false
  opts.on( '-t', '--thin', "Will set up thin configs as well" ) do
    options[:thin] = true
  end

  options[:nostart] = false
  opts.on( '--no-start', "Disable starting the app after activating" ) do
    options[:nostart] = true
  end

  options[:ports] = 2
  opts.on( '--ports PORTS', "Use PORTS number of ports") do |ports|
    options[:ports] = Integer(ports)
  end

end.parse!

action = ARGV[0]
domain = ARGV[1]
if ARGV.length < 2 && action != 'list'
  puts optparse
  exit
end
home = ENV['HOME']

matches = Dir.glob("*-#{domain}")
file_domain = matches[0] if matches.length > 0

case ARGV[0]
when 'new'
  # 1) Gather some data
  iterator = if File.exists?('.site_iterator')
    File.read('.site_iterator').gsub(/\D/,'').to_i
  else
    0
  end + 1
  File.open('.site_iterator', 'w') do |file|
    file << iterator
  end
  ports = [port_range + iterator*10]
  until ports.length == options[:ports]+1 # We have one port for nginx, plus one for each balanced service
    ports[ports.length] = ports.last+1
  end
  site_port = ports.shift
  service_ports = ports

  # 2) Copy the samples
  site_name = domain.gsub(/[\.]/,'_')
  require 'rubygems'
  require 'erb'
  File.open("#{iterator}-#{domain}", 'w') do |file|
    file << ERB.new(File.read("#{ENV['HOME']}/defaults/sample-site.com"), 0, "%<>").result
  end
  system("chown #{$user}:#{$user} #{ENV['HOME']}/SiteConfigs/#{iterator}-#{domain}")
  File.open("#{iterator}-#{domain}-thin.yml", 'w') do |file|
    file << ERB.new(File.read("#{ENV['HOME']}/defaults/sample-site.com.thin.yml"), 0, "%<>").result
  end if options[:thin]
  system("chown #{$user}:#{$user} #{ENV['HOME']}/SiteConfigs/#{iterator}-#{domain}-thin.yml") if options[:thin]
  File.open("#{iterator}-#{domain}.cfg", 'w') do |file|
    file << ERB.new(File.read("#{ENV['HOME']}/defaults/sample-site.com.cfg"), 0, "%<>").result
  end
  system("chown #{$user}:#{$user} #{ENV['HOME']}/SiteConfigs/#{iterator}-#{domain}.cfg")
  puts "Site #{domain} configs created and ready to activate."
when 'remove'
  if file_domain
    if File.exists?("/etc/nginx/sites-enabled/#{domain}") || File.exists?("/etc/nginx/sites-available/#{domain}") || File.exists?("/etc/haproxy/sites/#{domain}.cfg") || File.exists?("/etc/thin/#{domain}-thin.yml")
      puts "Can't remove #{domain} yet: Must deactivate first!"
    else
      system("rm #{home}/SiteConfigs/#{file_domain}*")
      puts "Site #{domain} removed."
    end
  else
    puts "Site #{domain} already removed."
  end
when 'activate'
  if File.exists?("/etc/nginx/sites-enabled/#{domain}") || File.exists?("/etc/nginx/sites-available/#{domain}") || File.exists?("/etc/haproxy/sites/#{domain}.cfg") || File.exists?("/etc/thin/#{domain}-thin.yml")
    puts "Site already active."
  else
    # 1) hardlink it into /etc/nginx/sites-available
    system("ln #{home}/SiteConfigs/#{file_domain} /etc/nginx/sites-available/#{domain}")
    # 2) symlink it into /etc/nginx/sites-enabled
    system("ln -s /etc/nginx/sites-available/#{domain} /etc/nginx/sites-enabled/#{domain}")
    # 3) hardlink thin config into /etc/thin
    system("ln #{home}/SiteConfigs/#{file_domain}-thin.yml /etc/thin/#{domain}-thin.yml") if File.exists?("#{home}/SiteConfigs/#{file_domain}-thin.yml")
    # 4) hardlink it into /etc/haproxy/sites
    system("ln #{home}/SiteConfigs/#{file_domain}.cfg /etc/haproxy/sites/#{domain}.cfg")
  end

  # Create a database and write database.production.yml
  linode_config = {
    :database => {
      :adapter => 'mysql',
      :host => 'localhost'
    }
  }

  # Create a database if there is none already.
  linode_config[:database][:database] = domain.gsub(/\./,'_')
  require 'digest/sha1'
  linode_config[:database][:username] = Digest::SHA1.hexdigest(domain)[0..15]
  linode_config[:database][:password] = String.random(40)
  YAML.update_file("#{home}/apps/#{domain}/config/database.production.yml") do |present_config|
    update_username = false
    update_password = false
    present_config[:database] = {} unless present_config[:database].is_a?(Hash)

    success, response = mysql("CREATE DATABASE #{linode_config[:database][:database]}")
    if success
      # Succeeds if database did not already exist, and was created.
      puts "Created mysql database #{linode_config[:database][:database]}."
    elsif response[0] == 1007
      puts "Database for this app already exists."
    else
      # ERROR 1007 -- database already exists
      # ERROR 1064 -- syntax error
      warn "!! COULD NOT CREATE DATABASE '#{linode_config[:database][:database]}': \"#{response[1]}\""
    end

    username_diff = present_config[:database][:username] != linode_config[:database][:username]
    # Change everything if the database name is different
    if present_config[:database][:database] != linode_config[:database][:database]
      present_config[:database].merge!(linode_config[:database])
      update_username = true
    end
    if username_diff
      # Change username AND password if username is not the same
      present_config[:database][:username] = linode_config[:database][:username]
      update_username = true
      present_config[:database][:password] = linode_config[:database][:password]
      update_password = true
    else
      # if password is not correct
      if `echo "quit" | mysql -u #{present_config[:database][:password]} --password=#{present_config[:database][:password]} #{present_config[:database][:database]} 2>&1` =~ /ERROR 1045/
        update_password = true
        present_config[:database][:password] = linode_config[:database][:password]
      end
    end
    success, response = mysql("CREATE USER '#{present_config[:database][:username]}'@'localhost' IDENTIFIED BY '#{present_config[:database][:password]}'")
    if success
      # User created. Now, grant the permissions.
      puts "Created user '#{present_config[:database][:username]}'@'localhost'."
      success, response = mysql("GRANT ALL ON #{present_config[:database][:database]}.* TO '#{present_config[:database][:username]}'@'localhost'")
      update_password = true
    elsif response[0] == 1396
      # User is already created. Change the password, unless the app already has a config.
      puts "User '#{present_config[:database][:username]}'@'localhost' already exists."
    else
      puts "Other CREATE USER error: #{response[1]}"
    end
    if update_password
      success, response = mysql("SET PASSWORD FOR '#{present_config[:database][:username]}'@'localhost' = PASSWORD('#{present_config[:database][:password]}')")
      puts "Changed database password for '#{present_config[:database][:username]}'@'localhost'."
    end
    # Let anything else overwrite the 'defaults'
    linode_config.merge!(present_config)
  end

  # Update the cilantro.yml to reflect the correct ports used for this app's services.
  if File.exists?("#{home}/apps/#{domain}/config/cilantro.yml")
    iterator = file_domain.match(/^(\d+)/)[1].to_i
    ports = [port_range + iterator*10]
    until ports.length == options[:ports]+1 # We have one port for nginx, plus one for each balanced service
      ports[ports.length] = ports.last+1
    end
    site_port = ports.shift
    service_ports = ports
    config = YAML.load_file(options[:config] || "#{home}/apps/#{domain}/config/cilantro.yml") || {}
    config[:ports] = service_ports
    File.open("#{home}/apps/#{domain}/config/cilantro.yml", 'w') do |cilantro|
      cilantro << config.to_yaml
    end
  end

  # 5) Reload haproxy
    system("/etc/init.d/haproxy reload")
  # 6) Reload nginx
    system("/etc/init.d/nginx reload")
  # 7) Start services that run this app
    unless options[:nostart]
      system("cd #{home}/apps/#{domain}; sudo -u www-data #{home}/apps/#{domain}/app-up") if File.exists?("#{home}/apps/#{domain}/app-up") && Dir.glob("#{home}/apps/#{domain}/log/app-up.pid").empty?
      # Cilantro
      if File.exists?("#{home}/apps/#{domain}/config/cilantro.yml")
        system("sudo -u www-data -H cilantro start #{home}/apps/#{domain} --database_config config/database.production.yml") if Dir.glob("#{home}/apps/#{domain}/log/*.pid").empty?
      # Thin
      elsif File.exists?("#{home}/SiteConfigs/#{file_domain}-thin.yml")
        system("thin start --config /etc/thin/#{domain}-thin.yml")
      end
    end
when 'deactivate'
  # 1) remove all of the configs from the active system
  system("rm /etc/nginx/sites-enabled/#{domain}") if File.exists?("/etc/nginx/sites-enabled/#{domain}")
  system("rm /etc/nginx/sites-available/#{domain}") if File.exists?("/etc/nginx/sites-available/#{domain}")
  system("rm /etc/thin/#{domain}-thin.yml") if File.exists?("/etc/thin/#{domain}-thin.yml")
  system("rm /etc/haproxy/sites/#{domain}.cfg") if File.exists?("/etc/haproxy/sites/#{domain}.cfg")

  # 2) Reload nginx
  system("/etc/init.d/nginx reload")
  # 3) Reload haproxy
  system("/etc/init.d/haproxy reload")
  # 4) Stop any services running this app
    # Cilantro
    if File.exists?("#{home}/apps/#{domain}/config/cilantro.yml")
      system("cilantro stop #{home}/apps/#{domain}")
    # Thin
    elsif File.exists?("#{home}/SiteConfigs/#{file_domain}-thin.yml")
      system("thin stop --config /etc/thin/#{domain}-thin.yml")
    end
    system("cd #{home}/apps/#{domain}; sudo -u www-data #{home}/apps/#{domain}/app-down") if File.exists?("#{home}/apps/#{domain}/app-down")
when 'list'
  matches = Dir.glob("*.cfg").select {|ha| ha =~ /^\d+-/}.collect {|ha| ha.match(/^\d+-(.+)\.cfg$/)[1]}
  puts "Managed Sites:\n\t#{matches.join("\n\t")}"
when 'status'
  if File.exists?("#{home}/apps/#{domain}/config/cilantro.yml")
    system("cilantro status #{home}/apps/#{domain}")
  else
    puts "Can't get status for #{domain}."
  end
when 'start'
  # Cilantro
  if File.exists?("#{home}/apps/#{domain}/config/cilantro.yml")
    system("sudo -u www-data -H cilantro start #{home}/apps/#{domain} --database_config config/database.production.yml")
  # Thin
  elsif File.exists?("#{home}/SiteConfigs/#{file_domain}-thin.yml")
    system("thin start --config /etc/thin/#{domain}-thin.yml")
  end
  system("cd #{home}/apps/#{domain}; sudo -u www-data #{home}/apps/#{domain}/app-up") if File.exists?("#{home}/apps/#{domain}/app-up")
when 'stop'
  system("cd #{home}/apps/#{domain}; sudo -u www-data #{home}/apps/#{domain}/app-down") if File.exists?("#{home}/apps/#{domain}/app-down")
  # Cilantro
  if File.exists?("#{home}/apps/#{domain}/config/cilantro.yml")
    system("cilantro stop #{home}/apps/#{domain}")
  # Thin
  elsif File.exists?("#{home}/SiteConfigs/#{file_domain}-thin.yml")
    system("thin stop --config /etc/thin/#{domain}-thin.yml")
  end
when 'restart'
  system("cd #{home}/apps/#{domain}; sudo -u www-data #{home}/apps/#{domain}/app-down") if File.exists?("#{home}/apps/#{domain}/app-down")
  # Cilantro
  if File.exists?("#{home}/apps/#{domain}/lib/cilantro.rb")
    system("cilantro stop #{home}/apps/#{domain}")
    sleep 0.5
    system("sudo -u www-data -H cilantro start #{home}/apps/#{domain} --database_config config/database.production.yml")
  # Thin
  elsif File.exists?("#{home}/SiteConfigs/#{file_domain}-thin.yml")
    system("thin stop --config /etc/thin/#{domain}-thin.yml")
    system("thin start --config /etc/thin/#{domain}-thin.yml")
  end
  system("cd #{home}/apps/#{domain}; sudo -u www-data #{home}/apps/#{domain}/app-up") if File.exists?("#{home}/apps/#{domain}/app-up")
end
